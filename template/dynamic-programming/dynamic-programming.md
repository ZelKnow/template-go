# 动态规划

动态规划是将原问题分解为相对简单的子问题逐步求解的方法，重点在于状态的定义。

## 背包问题

- 基本问题：令 `dp[i][j]` 表示前 `i` 件物品放入容量为 `j` 的背包中可以获得的最大价值
- 空间复杂度优化：只用一维的 `dp` 数组，外层循环对每个物品，内层循环从后往前遍历 `dp` ， `dp[i] = max(dp[i], dp[i-w]+v)`
- 若重量过大，可以令 `dp[i]` 表示共选取 `i` 价值的物品所需的最小重量
- 完全背包：循环遍历 `v` 时正着循环，因为此时需要用到前面的值
- 多重背包：将第 `i` 件物品拆分为 $k+1$ 件物品，其中它们的价值和重量分别为原本的价值和重量乘以 $1, 2, 2^2, \cdots, 2^{k-1}, M_i-2^k+1$ ，其中 $k$ 满足 $M_i-2^k+1 > 0$ 。这样选取任意数量的原物品均可以用选取这几种物品的某种组合来表示，这样就转化成了 01 背包问题。
- 分组背包问题：三层循环，第一层遍历所有组，第二层从后往前遍历重量，第三层遍历组内所有物品，`dp` 值为选与不选该物品的价值最大值。此时可以保证只选该组内一个物品（仔细体会）

## 一般问题

- [男女配对问题](https://atcoder.jp/contests/dp/tasks/dp_o)：考虑二进制表示 `i` ，表示前 `j` 个男生与 `i` 表示的女生配对，其中 `j` 为 `i` 二进制表示中 1 的个数
- [树形DP](https://atcoder.jp/contests/dp/tasks/dp_p)：DFS 即可。根节点的 `dp` 值为计算出子树们的 `dp` 值，然后再推出根节点。 典型的 `dp` 值为当根节点为白色时的方案数，以及根节点为黑色时的方案数
- 状压 DP：遍历子集 `for j:=i;j>=0;j=(j-1)&i`